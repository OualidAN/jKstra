{"version":3,"sources":["../../src/core/PriorityQueue.js"],"names":[],"mappings":"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","file":"PriorityQueue.js","sourcesContent":["\n/**\nBinary heap implementation of a priority queue\nwith an updateKey method.\n*/\nconst PriorityQueue = function(opts) {\n    const heap = [];\n\n    function compare(a, b) {\n        return a.key - b.key;\n    }\n\n    function bubbleUp(idx) {\n        let element = heap[idx];\n        let parentIdx;\n        let parent;\n        while (idx > 0) {\n            // Compute the parent element's index, and fetch it.\n            parentIdx = Math.floor((idx + 1) / 2) - 1;\n            parent = heap[parentIdx];\n            // If the parent has a lesser score, things are in order and we\n            // are done.\n            if (compare(element, parent) > 0) {\n                break;\n            }\n\n            // Otherwise, swap the parent with the current element and\n            // continue.\n            heap[parentIdx] = element;\n            heap[idx] = parent;\n            idx = parentIdx;\n        }\n    }\n\n    function sinkDown(idx) {\n        let length = heap.length;\n        let element = heap[idx];\n        let swapIdx;\n\n        while(true) {\n            let rChildIdx = (idx + 1) * 2;\n            let lChildIdx = rChildIdx - 1;\n            swapIdx = -1;\n\n            // if the first child exists\n            if (lChildIdx < length) {\n                let lChild = heap[lChildIdx];\n                // and is lower than the element, they must be swapped\n                if (compare(lChild, element) < 0) {\n                    swapIdx = lChildIdx;\n                }\n\n                // unless there is another lesser child, which will be the one swapped\n                if (rChildIdx < length) {\n                    const rChild = heap[rChildIdx];\n                    if ((swapIdx === -1 || compare(rChild, lChild) < 0) && compare(rChild, element) < 0) {\n                        swapIdx = rChildIdx;\n                    }\n                }\n            }\n\n            // if no swap occurs, the element found its right place\n            if (swapIdx === -1) {\n                break;\n            }\n\n            // otherwise, swap and continue on next tree level\n            heap[idx] = heap[swapIdx];\n            heap[swapIdx] = element;\n            idx = swapIdx;\n        }\n    }\n\n    // TODO: replace by native\n    function findElementIndex(elt) {\n        let idx = -1;\n        for(let i = 0, l = heap.length; i < l; i++) {\n            if(heap[i].elt === elt) {\n                idx = i;\n                break;\n            }\n        }\n        return idx;\n    }\n\n    return {\n        count: function() {\n            return heap.length;\n        },\n\n        insert: function(element, key) {\n            if (typeof element === 'undefined') {\n                throw new Error('No element provided');\n            }\n            heap.push({elt: element, key: key});\n            bubbleUp(heap.length - 1);\n        },\n\n        pop: function() {\n            if(heap.length === 0) {\n                throw new Error('Empty queue');\n            }\n            const elt = heap[0];\n            const end = heap.pop();\n            // replace the first element by the last,\n            // and let it sink to its right place\n            if (heap.length > 0) {\n                heap[0] = end;\n                sinkDown(0);\n            }\n            return elt;\n        },\n\n        peek: function() {\n            if(heap.length === 0) {\n                throw new Error('Empty queue');\n            }\n            return heap[0];\n        },\n\n        updateKey: function(element, newKey) {\n            const idx = findElementIndex(element);\n            if(idx === -1) {\n                throw new Error('The element is not in the heap');\n            }\n            const oldKey = heap[idx].key;\n            heap[idx].key = newKey;\n            if(newKey < oldKey) {\n                bubbleUp(idx);\n            } else {\n                sinkDown(idx);\n            }\n        }\n    };\n};\n\nexport default PriorityQueue;\n"]}