{"version":3,"sources":["../../src/core/PriorityQueue.js"],"names":[],"mappings":"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","file":"PriorityQueue.js","sourcesContent":["\n/**\nBinary heap implementation of a priority queue\nwith an updateKey method.\n*/\nconst PriorityQueue = function(opts) {\n    const heap = [];\n\n    // TODO: make it an option, for max or min priority queue\n    function compare(a, b) {\n        return a.key - b.key;\n    }\n\n    function bubbleUp(idx) {\n        let element = heap[idx];\n        let parentIdx;\n        let parent;\n        while (idx > 0) {\n            // Compute the parent element's index, and fetch it.\n            parentIdx = Math.floor((idx + 1) / 2) - 1;\n            parent = heap[parentIdx];\n            // If the parent has a lesser score, things are in order and we\n            // are done.\n            if (compare(element, parent) > 0) {\n                break;\n            }\n\n            // Otherwise, swap the parent with the current element and\n            // continue.\n            heap[parentIdx] = element;\n            heap[idx] = parent;\n            idx = parentIdx;\n        }\n    }\n\n    function sinkDown(idx) {\n        let length = heap.length;\n        let element = heap[idx];\n        let swapIdx;\n\n        while(true) {\n            let rChildIdx = (idx + 1) * 2;\n            let lChildIdx = rChildIdx - 1;\n            swapIdx = -1;\n\n            // if the first child exists\n            if (lChildIdx < length) {\n                let lChild = heap[lChildIdx];\n                // and is lower than the element, they must be swapped\n                if (compare(lChild, element) < 0) {\n                    swapIdx = lChildIdx;\n                }\n\n                // unless there is another lesser child, which will be the one swapped\n                if (rChildIdx < length) {\n                    const rChild = heap[rChildIdx];\n                    if ((swapIdx === -1 || compare(rChild, lChild) < 0) && compare(rChild, element) < 0) {\n                        swapIdx = rChildIdx;\n                    }\n                }\n            }\n\n            // if no swap occurs, the element found its right place\n            if (swapIdx === -1) {\n                break;\n            }\n\n            // otherwise, swap and continue on next tree level\n            heap[idx] = heap[swapIdx];\n            heap[swapIdx] = element;\n            idx = swapIdx;\n        }\n    }\n\n    function findElementIndex(elt) {\n        for(let i = 0, l = heap.length; i < l; i++) {\n            if(heap[i].elt === elt) { return i; }\n        }\n        return -1;\n    }\n\n    return {\n        count() {\n            return heap.length;\n        },\n\n        insert(element, key) {\n            if (typeof element === 'undefined') {\n                throw new Error('No element provided');\n            }\n            heap.push({elt: element, key: key});\n            bubbleUp(heap.length - 1);\n        },\n\n        pop() {\n            if(heap.length === 0) {\n                throw new Error('Empty queue');\n            }\n            const elt = heap[0];\n            const end = heap.pop();\n            // replace the first element by the last,\n            // and let it sink to its right place\n            if (heap.length > 0) {\n                heap[0] = end;\n                sinkDown(0);\n            }\n            return elt;\n        },\n\n        peek() {\n            if(heap.length === 0) {\n                throw new Error('Empty queue');\n            }\n            return heap[0];\n        },\n\n        updateKey(element, newKey) {\n            const idx = findElementIndex(element);\n            if(idx === -1) {\n                throw new Error('The element is not in the heap');\n            }\n            const oldKey = heap[idx].key;\n            heap[idx].key = newKey;\n            if(newKey < oldKey) {\n                bubbleUp(idx);\n            } else {\n                sinkDown(idx);\n            }\n        }\n    };\n};\n\nexport default PriorityQueue;\n"]}