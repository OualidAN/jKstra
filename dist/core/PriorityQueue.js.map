{"version":3,"sources":["../../src/core/PriorityQueue.js"],"names":[],"mappings":";;;;;;;;;;;;;;;IAKM;AACF,aADE,aACF,GAAc;8BADZ,eACY;;AACV,aAAK,IAAL,GAAY,EAAZ,CADU;KAAd;;;;;iBADE;;iCAMO,GAAG,GAAG;AACX,mBAAO,EAAE,GAAF,GAAQ,EAAE,GAAF,CADJ;;;;kCAIL,KAAK;AACX,gBAAI,UAAU,KAAK,IAAL,CAAU,GAAV,CAAV,CADO;AAEX,gBAAI,kBAAJ,CAFW;AAGX,gBAAI,eAAJ,CAHW;AAIX,mBAAO,MAAM,CAAN,EAAS;;AAEZ,4BAAY,KAAK,KAAL,CAAW,CAAC,MAAM,CAAN,CAAD,GAAY,CAAZ,CAAX,GAA4B,CAA5B,CAFA;AAGZ,yBAAS,KAAK,IAAL,CAAU,SAAV,CAAT;;;AAHY,oBAMR,KAAK,QAAL,CAAc,OAAd,EAAuB,MAAvB,IAAiC,CAAjC,EAAoC;AACpC,0BADoC;iBAAxC;;;;AANY,oBAYZ,CAAK,IAAL,CAAU,SAAV,IAAuB,OAAvB,CAZY;AAaZ,qBAAK,IAAL,CAAU,GAAV,IAAiB,MAAjB,CAbY;AAcZ,sBAAM,SAAN,CAdY;aAAhB;;;;kCAkBM,KAAK;AACX,gBAAI,SAAS,KAAK,IAAL,CAAU,MAAV,CADF;AAEX,gBAAI,UAAU,KAAK,IAAL,CAAU,GAAV,CAAV,CAFO;AAGX,gBAAI,gBAAJ,CAHW;;AAKX,mBAAM,IAAN,EAAY;AACR,oBAAI,YAAY,CAAC,MAAM,CAAN,CAAD,GAAY,CAAZ,CADR;AAER,oBAAI,YAAY,YAAY,CAAZ,CAFR;AAGR,0BAAU,CAAC,CAAD;;;AAHF,oBAMJ,YAAY,MAAZ,EAAoB;AACpB,wBAAI,SAAS,KAAK,IAAL,CAAU,SAAV,CAAT;;AADgB,wBAGhB,KAAK,QAAL,CAAc,MAAd,EAAsB,OAAtB,IAAiC,CAAjC,EAAoC;AACpC,kCAAU,SAAV,CADoC;qBAAxC;;;AAHoB,wBAQhB,YAAY,MAAZ,EAAoB;AACpB,4BAAM,SAAS,KAAK,IAAL,CAAU,SAAV,CAAT,CADc;AAEpB,4BAAI,CAAC,YAAY,CAAC,CAAD,IAAM,KAAK,QAAL,CAAc,MAAd,EAAsB,MAAtB,IAAgC,CAAhC,CAAnB,IAAyD,KAAK,QAAL,CAAc,MAAd,EAAsB,OAAtB,IAAiC,CAAjC,EAAoC;AAC7F,sCAAU,SAAV,CAD6F;yBAAjG;qBAFJ;iBARJ;;;AANQ,oBAuBJ,YAAY,CAAC,CAAD,EAAI;AAChB,0BADgB;iBAApB;;;AAvBQ,oBA4BR,CAAK,IAAL,CAAU,GAAV,IAAiB,KAAK,IAAL,CAAU,OAAV,CAAjB,CA5BQ;AA6BR,qBAAK,IAAL,CAAU,OAAV,IAAqB,OAArB,CA7BQ;AA8BR,sBAAM,OAAN,CA9BQ;aAAZ;;;;0CAkCc,KAAK;AACnB,iBAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,KAAK,IAAL,CAAU,MAAV,EAAkB,IAAI,CAAJ,EAAO,GAA7C,EAAkD;AAC9C,oBAAI,KAAK,IAAL,CAAU,CAAV,EAAa,GAAb,KAAqB,GAArB,EAA0B;AAAE,2BAAO,CAAP,CAAF;iBAA9B;aADJ;AAGA,mBAAO,CAAC,CAAD,CAJY;;;;+BAWhB,SAAS,KAAK;AACjB,iBAAK,IAAL,CAAU,IAAV,CAAe,EAAC,KAAK,OAAL,EAAc,KAAK,GAAL,EAA9B,EADiB;AAEjB,iBAAK,SAAL,CAAe,KAAK,IAAL,CAAU,MAAV,GAAmB,CAAnB,CAAf,CAFiB;;;;8BAKf;AACF,gBAAI,KAAK,IAAL,CAAU,MAAV,KAAqB,CAArB,EAAwB;AACxB,uBAAO,IAAP,CADwB;aAA5B;AAGA,gBAAM,MAAM,KAAK,IAAL,CAAU,CAAV,CAAN,CAJJ;AAKF,gBAAM,MAAM,KAAK,IAAL,CAAU,GAAV,EAAN;;;AALJ,gBAQE,KAAK,IAAL,CAAU,MAAV,GAAmB,CAAnB,EAAsB;AACtB,qBAAK,IAAL,CAAU,CAAV,IAAe,GAAf,CADsB;AAEtB,qBAAK,SAAL,CAAe,CAAf,EAFsB;aAA1B;AAIA,mBAAO,GAAP,CAZE;;;;+BAeC;AACH,gBAAI,KAAK,IAAL,CAAU,MAAV,KAAqB,CAArB,EAAwB;AACxB,uBAAO,IAAP,CADwB;aAA5B;AAGA,mBAAO,KAAK,IAAL,CAAU,CAAV,CAAP,CAJG;;;;kCAOG,SAAS,QAAQ;AACvB,gBAAM,MAAM,KAAK,iBAAL,CAAuB,OAAvB,CAAN,CADiB;AAEvB,gBAAI,QAAQ,CAAC,CAAD,EAAI;AACZ,uBADY;aAAhB;AAGA,gBAAM,SAAS,KAAK,IAAL,CAAU,GAAV,EAAe,GAAf,CALQ;AAMvB,iBAAK,IAAL,CAAU,GAAV,EAAe,GAAf,GAAqB,MAArB,CANuB;AAOvB,gBAAI,SAAS,MAAT,EAAiB;AACjB,qBAAK,SAAL,CAAe,GAAf,EADiB;aAArB,MAEO;AACH,qBAAK,SAAL,CAAe,GAAf,EADG;aAFP;;;;4BAtCQ;AACR,mBAAO,KAAK,IAAL,CAAU,MAAV,CADC;;;;WA9EV;;;AA0HL;;kBAEc","file":"PriorityQueue.js","sourcesContent":["\n/**\nBinary this.heap implementation of a priority queue\nwith an updateKey method.\n*/\nclass PriorityQueue {\n    constructor() {\n        this.heap = [];\n    }\n\n    // TODO: make it an option, for max or min priority queue\n    _compare(a, b) {\n        return a.key - b.key;\n    }\n\n    _bubbleUp(idx) {\n        let element = this.heap[idx];\n        let parentIdx;\n        let parent;\n        while (idx > 0) {\n            // Compute the parent element's index, and fetch it.\n            parentIdx = Math.floor((idx + 1) / 2) - 1;\n            parent = this.heap[parentIdx];\n            // If the parent has a lesser score, things are in order and we\n            // are done.\n            if (this._compare(element, parent) > 0) {\n                break;\n            }\n\n            // Otherwise, swap the parent with the current element and\n            // continue.\n            this.heap[parentIdx] = element;\n            this.heap[idx] = parent;\n            idx = parentIdx;\n        }\n    }\n\n    _sinkDown(idx) {\n        let length = this.heap.length;\n        let element = this.heap[idx];\n        let swapIdx;\n\n        while(true) {\n            let rChildIdx = (idx + 1) * 2;\n            let lChildIdx = rChildIdx - 1;\n            swapIdx = -1;\n\n            // if the first child exists\n            if (lChildIdx < length) {\n                let lChild = this.heap[lChildIdx];\n                // and is lower than the element, they must be swapped\n                if (this._compare(lChild, element) < 0) {\n                    swapIdx = lChildIdx;\n                }\n\n                // unless there is another lesser child, which will be the one swapped\n                if (rChildIdx < length) {\n                    const rChild = this.heap[rChildIdx];\n                    if ((swapIdx === -1 || this._compare(rChild, lChild) < 0) && this._compare(rChild, element) < 0) {\n                        swapIdx = rChildIdx;\n                    }\n                }\n            }\n\n            // if no swap occurs, the element found its right place\n            if (swapIdx === -1) {\n                break;\n            }\n\n            // otherwise, swap and continue on next tree level\n            this.heap[idx] = this.heap[swapIdx];\n            this.heap[swapIdx] = element;\n            idx = swapIdx;\n        }\n    }\n\n    _findElementIndex(elt) {\n        for (let i = 0, l = this.heap.length; i < l; i++) {\n            if (this.heap[i].elt === elt) { return i; }\n        }\n        return -1;\n    }\n\n    get count() {\n        return this.heap.length;\n    }\n\n    insert(element, key) {\n        this.heap.push({elt: element, key: key});\n        this._bubbleUp(this.heap.length - 1);\n    }\n\n    pop() {\n        if (this.heap.length === 0) {\n            return null;\n        }\n        const elt = this.heap[0];\n        const end = this.heap.pop();\n        // replace the first element by the last,\n        // and let it sink to its right place\n        if (this.heap.length > 0) {\n            this.heap[0] = end;\n            this._sinkDown(0);\n        }\n        return elt;\n    }\n\n    peek() {\n        if (this.heap.length === 0) {\n            return null;\n        }\n        return this.heap[0];\n    }\n\n    updateKey(element, newKey) {\n        const idx = this._findElementIndex(element);\n        if (idx === -1) {\n            return;\n        }\n        const oldKey = this.heap[idx].key;\n        this.heap[idx].key = newKey;\n        if (newKey < oldKey) {\n            this._bubbleUp(idx);\n        } else {\n            this._sinkDown(idx);\n        }\n    }\n};\n\nexport default PriorityQueue;\n"]}