{"version":3,"sources":["../../src/algos/Dijkstra.js"],"names":[],"mappings":"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","file":"Dijkstra.js","sourcesContent":["import { REACHED, SETTLED } from 'status.js';\nimport PriorityQueue from '../PriorityQueue.js';\nimport extend from '../core/utils.js';\n\nfunction Dijkstra(graph, opts) {\n    let options = extend(\n        {\n            flagKey: '_dijkstra'\n        },\n        opts\n    );\n    let flagKey = options.flagKey;\n\n    function clearFlags() {\n        graph.forEachVertex(function(v) {\n            delete v[flagKey];\n        });\n    }\n\n    function getFlags(v) {\n        return v[flagKey] || {};\n    }\n\n    function setFlags(v, flags) {\n        if(!v.hasOwnProperty(flagKey)) {\n            v[flagKey] = {};\n        }\n        for(let key in flags) {\n            v[flagKey][key] = flags[key];\n        }\n    }\n\n    /**\n    @param v {Vertex}\n    @param incEge {Edge} the incoming edge\n    @param cost {the cost }\n    */\n    function reach(v, incEdge, cost, action) {\n        // update state to \"reached\", and register cost and incomingEdge\n        setFlags(v, {state: REACHED, cost: cost, inc: incEdge});\n        if(action) {\n            action(v, incEdge, cost);\n        }\n    }\n\n    function settle(v, action) {\n        setFlags(v, {state: SETTLED});\n        if(action) {\n            action(v);\n        }\n    }\n\n    function rebuildPath(end) {\n        const edges = [];\n        let edge;\n        // going upward in the tree until the first vertex (with no incoming edge)\n        while((edge = getFlags(end).inc) != null) {\n            edges.push(edge);\n            end = edge.from;\n        }\n        return edges.reverse();\n    }\n\n    const defaultTraversalOptions = {\n        shouldUpdateKey: function(prevCost, newCost) {\n            return newCost < prevCost;\n        },\n        edgeCost: function(e, costDone) {\n            return 1;\n        },\n        isFinished: function(direction) {\n            return false;\n        },\n        onReach: null,        // nothing special to do when reaching a node\n        onSettle: null,     // nothing special to do when setting a node\n        edgeFilter: null    // take all edges\n    };\n\n    return {\n        /**\n        The most common use of Dijkstra traversal\n        */\n        shortestPath: function(source, target, opts) {\n            function isTargetFound() {\n                return getFlags(target).state === SETTLED;\n            }\n\n            const options = opts || {};\n            options.isFinished = isTargetFound;\n\n            const found = this.traverse(source, options);\n            if(found) {\n                return rebuildPath(target);\n            }\n            return null;\n        },\n\n        /**\n        Traverse the graph using Dijkstra's algorithm,\n        starting from source, with the specified options\n        */\n        traverse: function(source, opts) {\n            const options = extend(\n                defaultTraversalOptions,\n                opts\n            );\n\n            // reset node tagging\n            clearFlags();\n\n            let kv;\n            let u, v;\n            let e;\n            let totalCost, eCost;\n            let vFlags;\n\n            const Q = new PriorityQueue();\n            Q.insert(source, 0);\n            reach(source, null, 0, options.onReach);\n\n            while(!options.isFinished(true) && Q.count() > 0) {\n                kv = Q.pop();\n                u = kv.elt;\n                totalCost = kv.key;\n                settle(u, options.onSettle);\n\n                const edges = graph.outEdges(u, options.edgeFilter);\n                for(let i = 0; i < edges.length; i++) {\n                    e = edges[i];\n                    v = e.to;\n                    eCost = totalCost + options.edgeCost(e, totalCost);\n                    vFlags = getFlags(v);\n\n                    if(vFlags.state !== SETTLED) {\n                        if(vFlags.state !== REACHED) {\n                            Q.insert(v, eCost);\n                            reach(v, e, eCost, options.onReach);\n                        } else {\n                            if (options.shouldUpdateKey(vFlags.cost, eCost, vFlags.inc, e)) {\n                            // else if (eCost < vFlags.cost) { // if already reached but new cost is less than current\n                                Q.updateKey(v, eCost);\n                                reach(v, e, eCost, options.onReach);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // if false, means the whole graph was traversed\n            return options.isFinished(true);\n        }\n    };\n};\n\nexport default Dijkstra;\n"]}