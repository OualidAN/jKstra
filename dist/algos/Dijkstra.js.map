{"version":3,"sources":["../../src/algos/Dijkstra.js"],"names":[],"mappings":"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","file":"Dijkstra.js","sourcesContent":["import PriorityQueue from '../core/PriorityQueue.js';\nconst SETTLED = 2;\nconst REACHED = 1;\n\nclass Dijkstra {\n    constructor(graph, opts) {\n        this.graph = graph;\n        const options = Object.assign({ flagKey: '_dijkstra' }, opts);\n        this.flagKey = options.flagKey;\n    }\n\n    // TODO: move these 3 functions to some utils\n    _clearFlags() {\n        this.graph.forEachVertex(v => {\n            delete v[this.flagKey];\n        });\n    }\n\n    _getFlags(v) {\n        return v[this.flagKey] || {};\n    }\n\n    _setFlags(v, flags) {\n        if (!v.hasOwnProperty(this.flagKey)) {\n            v[this.flagKey] = {};\n        }\n        for (let key in flags) {\n            v[this.flagKey][key] = flags[key];\n        }\n    }\n\n    _reach(v, incEdge, cost, action) {\n        // update state to \"reached\", and register cost and incomingEdge\n        this._setFlags(v, {state: REACHED, cost, inc: incEdge});\n        if (action) {\n            action(v, incEdge, cost);\n        }\n    }\n\n    _settle(v, action) {\n        this._setFlags(v, {state: SETTLED});\n        if (action) {\n            action(v);\n        }\n    }\n\n    rebuildPath(end) {\n        const edges = [];\n        let edge;\n        // going upward in the tree until the first vertex (with no incoming edge)\n        while ((edge = this._getFlags(end).inc) !== null) {\n            edges.push(edge);\n            end = edge.from;\n        }\n        return edges.reverse();\n    }\n\n    static defaultTraversalOptions = {\n        shouldUpdateKey: (prevCost, newCost) => { return newCost < prevCost; },\n        edgeCost: (e, costDone) => 1,\n        isFinished: direction => false,\n        heuristic: v => 0,\n        onReach: null,        // nothing special to do when reaching a node\n        onSettle: null,     // nothing special to do when setting a node\n        edgeFilter: null    // take all edges\n    }\n\n    /**\n    The most common use of Dijkstra traversal\n    */\n    shortestPath(source, target, opts) {\n        function isTargetFound() {\n            return this._getFlags(target).state === SETTLED;\n        }\n\n        const options = opts || {};\n        options.isFinished = isTargetFound.bind(this);\n\n        const found = this.traverse(source, options);\n        if(found) {\n            return this.rebuildPath(target);\n        }\n        return null;\n    }\n\n    /**\n    Traverse the graph using Dijkstra's algorithm,\n    starting from source, with the specified options\n    */\n    traverse(source, opts) {\n        const options = Object.assign({}, Dijkstra.defaultTraversalOptions, opts);\n        const {\n            edgeFilter,\n            edgeCost,\n            heuristic,\n            shouldUpdateKey,\n            onReach,\n            onSettle,\n            isFinished\n        } = options;\n\n        // reset node tagging\n        this._clearFlags();\n\n        let kv;\n        let u, v;\n        let totalCost, eCost;\n        let vFlags;\n\n        const Q = new PriorityQueue();\n        Q.insert(source, 0);\n        this._reach(source, null, 0, onReach);\n\n        while (!isFinished() && Q.count > 0) {\n            kv = Q.pop();\n            u = kv.elt;\n            totalCost = kv.key;\n            this._settle(u, onSettle);\n\n            const edges = this.graph.outEdges(u, edgeFilter);\n            for (let e of edges) {\n                v = e.to;\n                eCost = totalCost + edgeCost(e, totalCost) + heuristic(v);\n                vFlags = this._getFlags(v);\n\n                if (vFlags.state !== SETTLED) {\n                    if (vFlags.state !== REACHED) {\n                        Q.insert(v, eCost);\n                        this._reach(v, e, eCost, onReach);\n                    } else {\n                        if (shouldUpdateKey(vFlags.cost, eCost, vFlags.inc, e)) {\n                        // else if (eCost < vFlags.cost) { // if already reached but new cost is less than current\n                            Q.updateKey(v, eCost);\n                            this._reach(v, e, eCost, onReach);\n                        }\n                    }\n                }\n            }\n        }\n\n        // if false, means the whole graph was traversed\n        return isFinished();\n    }\n};\n\nexport default Dijkstra;\n"]}