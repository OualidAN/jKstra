{"version":3,"sources":["../../src/algos/Dijkstra.js"],"names":[],"mappings":"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","file":"Dijkstra.js","sourcesContent":["import PriorityQueue from '../core/PriorityQueue.js';\nconst SETTLED = 2;\nconst REACHED = 1;\n\nfunction Dijkstra(graph, opts) {\n    const options = Object.assign({ flagKey: '_dijkstra' }, opts);\n    let flagKey = options.flagKey;\n\n    function clearFlags() {\n        graph.forEachVertex(function(v) {\n            delete v[flagKey];\n        });\n    }\n\n    function getFlags(v) {\n        return v[flagKey] || {};\n    }\n\n    function setFlags(v, flags) {\n        if(!v.hasOwnProperty(flagKey)) {\n            v[flagKey] = {};\n        }\n        for(let key in flags) {\n            v[flagKey][key] = flags[key];\n        }\n    }\n\n    /**\n    @param v {Vertex}\n    @param incEge {Edge} the incoming edge\n    @param cost {the cost }\n    */\n    function reach(v, incEdge, cost, action) {\n        // update state to \"reached\", and register cost and incomingEdge\n        setFlags(v, {state: REACHED, cost, inc: incEdge});\n        if(action) {\n            action(v, incEdge, cost);\n        }\n    }\n\n    function settle(v, action) {\n        setFlags(v, {state: SETTLED});\n        if(action) {\n            action(v);\n        }\n    }\n\n    function rebuildPath(end) {\n        const edges = [];\n        let edge;\n        // going upward in the tree until the first vertex (with no incoming edge)\n        while((edge = getFlags(end).inc) != null) {\n            edges.push(edge);\n            end = edge.from;\n        }\n        return edges.reverse();\n    }\n\n    const defaultTraversalOptions = {\n        shouldUpdateKey: (prevCost, newCost) => { return newCost < prevCost; },\n        edgeCost: (e, costDone) => 1,\n        isFinished: direction => false,\n        heuristic: v => 0,\n        onReach: null,        // nothing special to do when reaching a node\n        onSettle: null,     // nothing special to do when setting a node\n        edgeFilter: null    // take all edges\n    };\n\n    return {\n        /**\n        The most common use of Dijkstra traversal\n        */\n        shortestPath(source, target, opts) {\n            function isTargetFound() {\n                return getFlags(target).state === SETTLED;\n            }\n\n            const options = opts || {};\n            options.isFinished = isTargetFound;\n\n            const found = this.traverse(source, options);\n            if(found) {\n                return rebuildPath(target);\n            }\n            return null;\n        },\n\n        /**\n        Traverse the graph using Dijkstra's algorithm,\n        starting from source, with the specified options\n        */\n        traverse(source, opts) {\n            const options = Object.assign({}, defaultTraversalOptions, opts);\n            const {\n                edgeFilter,\n                edgeCost,\n                heuristic,\n                shouldUpdateKey,\n                onReach,\n                onSettle,\n                isFinished\n            } = options;\n\n            // reset node tagging\n            clearFlags();\n\n            let kv;\n            let u, v;\n            let e;\n            let totalCost, eCost;\n            let vFlags;\n\n            const Q = new PriorityQueue();\n            Q.insert(source, 0);\n            reach(source, null, 0, onReach);\n\n            while(!isFinished() && Q.count > 0) {\n                kv = Q.pop();\n                u = kv.elt;\n                totalCost = kv.key;\n                settle(u, onSettle);\n\n                const edges = graph.outEdges(u, edgeFilter);\n                for(let i = 0; i < edges.length; i++) {\n                    e = edges[i];\n                    v = e.to;\n                    eCost = totalCost + edgeCost(e, totalCost) + heuristic(v);\n                    vFlags = getFlags(v);\n\n                    if(vFlags.state !== SETTLED) {\n                        if(vFlags.state !== REACHED) {\n                            Q.insert(v, eCost);\n                            reach(v, e, eCost, onReach);\n                        } else {\n                            if (shouldUpdateKey(vFlags.cost, eCost, vFlags.inc, e)) {\n                            // else if (eCost < vFlags.cost) { // if already reached but new cost is less than current\n                                Q.updateKey(v, eCost);\n                                reach(v, e, eCost, onReach);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // if false, means the whole graph was traversed\n            return isFinished();\n        }\n    };\n};\n\nexport default Dijkstra;\n"]}