{"version":3,"sources":["../../src/algos/DijkstraIterator.js"],"names":[],"mappings":"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","file":"DijkstraIterator.js","sourcesContent":["import PriorityQueue from '../core/PriorityQueue.js';\nconst SETTLED = 2;\nconst REACHED = 1;\n\nclass DijkstraIterator {\n    static defaultOptions = {\n        flagKey: '_dijkstra',\n        shouldUpdateKey: (prevCost, newCost) => { return newCost < prevCost; },\n        edgeCost: (e, costDone) => 1,\n        heuristic: v => 0,\n        onReach: null,        // nothing special to do when reaching a node\n        onSettle: null,     // nothing special to do when setting a node\n        edgeFilter: null    // take all edges\n    }\n\n    constructor(graph, source, opts) {\n        this.graph = graph;\n        this.source = source;\n        this.options = Object.assign({}, DijkstraIterator.defaultOptions, opts);\n        this.flagKey = this.options.flagKey;\n\n        this.pQ = new PriorityQueue();\n        this._initTraversal();\n    }\n\n    // TODO: move these 3 functions to some utils\n    _clearFlags() {\n        this.graph.forEachVertex(v => {\n            delete v[this.flagKey];\n        });\n    }\n\n    _getFlags(v) {\n        return v[this.flagKey] || {};\n    }\n\n    _setFlags(v, flags) {\n        if (!v.hasOwnProperty(this.flagKey)) {\n            v[this.flagKey] = {};\n        }\n        for (let key in flags) {\n            v[this.flagKey][key] = flags[key];\n        }\n    }\n\n    _reach(v, incEdge, cost, action) {\n        // update state to \"reached\", and register cost and incomingEdge\n        this._setFlags(v, {state: REACHED, cost, inc: incEdge});\n        if (action) {\n            action(v, incEdge, cost);\n        }\n    }\n\n    _settle(v, action) {\n        this._setFlags(v, {state: SETTLED});\n        if (action) {\n            action(v);\n        }\n    }\n\n    _initTraversal() {\n        // reset node tagging\n        this._clearFlags();\n        this.pQ.insert(this.source, 0);\n        this._reach(this.source, null, 0, this.options.onReach);\n    }\n\n    next() {\n        // if no more node available in the queue,\n        // return the iterator end signal\n        if (this.pQ.count === 0) {\n            return { done: true };\n        }\n\n        const {\n            onReach,\n            onSettle,\n            edgeFilter,\n            edgeCost,\n            heuristic,\n            shouldUpdateKey\n        } = this.options;\n\n        const kv = this.pQ.pop();\n        const u = kv.elt;\n        let v;\n        let vFlags;\n        const totalCost = kv.key;\n        let eCost;\n\n        this._settle(u, onSettle);\n        const edges = this.graph.outEdges(u, edgeFilter);\n        for (let e of edges) {\n            v = e.to;\n            eCost = totalCost + edgeCost(e, totalCost) + heuristic(v);\n            vFlags = this._getFlags(v);\n\n            if (vFlags.state !== SETTLED) {\n                if (vFlags.state !== REACHED) {\n                    this.pQ.insert(v, eCost);\n                    this._reach(v, e, eCost, onReach);\n                } else {\n                    if (shouldUpdateKey(vFlags.cost, eCost, vFlags.inc, e)) {\n                        this.pQ.updateKey(v, eCost);\n                        this._reach(v, e, eCost, onReach);\n                    }\n                }\n            }\n        }\n\n        return { value: u };\n    }\n};\n\nexport default DijkstraIterator;\n"]}