{"version":3,"sources":["../../src/algos/DijkstraIterator.js"],"names":[],"mappings":"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","file":"DijkstraIterator.js","sourcesContent":["import PriorityQueue from '../core/PriorityQueue.js';\nimport NodeFlagger from './nodeFlagger.js';\nimport { OUT, SETTLED, REACHED } from '../core/constants.js';\n\nclass DijkstraIterator {\n    static defaultOptions = {\n        flagKey: '_dijkstra',\n        direction: OUT,\n        shouldUpdateKey: (prevCost, newCost) => { return newCost < prevCost; },\n        edgeCost: (e, costDone) => 1,\n        heuristic: v => 0,\n        onReach: null,        // nothing special to do when reaching a node\n        onSettle: null,     // nothing special to do when setting a node\n        edgeFilter: null    // take all edges\n    }\n\n    constructor(graph, source, opts) {\n        this.graph = graph;\n        this.source = source;\n        this.options = Object.assign({}, DijkstraIterator.defaultOptions, opts);\n        this.flags = new NodeFlagger(this.graph, this.options.flagKey);\n\n        this.pQ = new PriorityQueue();\n        this._initTraversal();\n    }\n\n    _reach(v, incEdge, cost, action) {\n        // update state to \"reached\", and register cost and incomingEdge\n        this.flags.setFlags(v, {state: REACHED, cost, inc: incEdge});\n        if (action) {\n            action(v, incEdge, cost);\n        }\n    }\n\n    _settle(v, action) {\n        this.flags.setFlags(v, {state: SETTLED});\n        if (action) {\n            action(v);\n        }\n    }\n\n    _initTraversal() {\n        // reset node tagging\n        this.flags.clearFlags(this.graph);\n        this.pQ.insert(this.source, this.options.heuristic(this.source));\n        this._reach(this.source, null, this.options.heuristic(this.source), this.options.onReach);\n    }\n\n    next() {\n        // if no more node available in the queue,\n        // return the iterator end signal\n        if (this.pQ.count === 0) {\n            return { done: true };\n        }\n\n        const {\n            direction,\n            onReach,\n            onSettle,\n            edgeFilter,\n            edgeCost,\n            heuristic,\n            shouldUpdateKey\n        } = this.options;\n\n        const kv = this.pQ.pop();\n        const u = kv.elt;\n        let v;\n        let vFlags;\n        const totalCost = kv.key;\n        let eCost;\n\n        this._settle(u, onSettle);\n        const edges = this.graph.incidentEdges(u, direction, edgeFilter);\n        for (let e of edges) {\n            v = direction === OUT ? e.to : e.from;\n            eCost = totalCost + edgeCost(e, totalCost) + heuristic(v);\n            vFlags = this.flags.getFlags(v);\n\n            if (vFlags.state !== SETTLED) {\n                if (vFlags.state !== REACHED) {\n                    this.pQ.insert(v, eCost);\n                    this._reach(v, e, eCost, onReach);\n                } else {\n                    if (shouldUpdateKey(vFlags.cost, eCost, vFlags.inc, e)) {\n                        this.pQ.updateKey(v, eCost);\n                        this._reach(v, e, eCost, onReach);\n                    }\n                }\n            }\n        }\n\n        return { value: u };\n    }\n};\n\nexport default DijkstraIterator;\n"]}